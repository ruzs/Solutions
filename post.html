<h2>#include &lt;numeric&gt;</h2>
<h3>1. std::iota</h3>
<pre class="language-cpp"><code>template &lt;class ForwardIterator, class T&gt;
  void iota (ForwardIterator first, ForwardIterator last, T val);</code></pre>
<p>[ first, last )의 원소들을 [ val, val+1, val+2, ... ]로 채워준다. $O(N)$</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<p>disjoint_set의 초기값을 0, 1, 2, 3, 4, ... 로 하는 경우,</p>
<pre class="language-cpp"><code>struct dsu {
    vector&lt;int&gt; a;
    dsu(int n) {
        a.resize(n);
        iota(a.begin(), a.end(), 0);
    }
    ...
}</code></pre>
<p>와 같이 간편하게 작성할 수 있다.</p>
</div>
</div>
<h3>2. std::partial_sum</h3>
<pre class="language-cpp"><code>template &lt;class InputIterator, class OutputIterator&gt;
  OutputIterator partial_sum (InputIterator first, InputIterator last, OutputIterator result);</code></pre>
<p><span style="color: #333333;">result로 시작하는 배열에 </span>[ first, last )의 정적 부분합 배열 결과를 저장한다. $O(N)$</p>
<p><span style="color: #333333;">custom 함수를 이용하면 사용자 정의 연산결과를 얻을 수 있다.</span></p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<pre class="language-cpp"><code>vector&lt;int&gt; a = {1, 2, 3, 4, 5};
vector&lt;int&gt; b(a.size());

partial_sum(a.begin(), a.end(), b.begin());
// b = [ 1, 3, 6, 10, 15 ]

// custom function 사용이 가능
partial_sum(a.begin(), a.end(), b.begin(), [](int a, int b) { return a + b + 1; });
// b = [ 1, 4, 8, 13, 19 ]

// factorial
partial_sum(a.begin(), a.end(), b.begin(), [](int a, int b) { return a * b; });
// b = [ 1, 2, 6, 24, 120 ]
    
// 제곱의 부분합 배열도 다음과 같이 얻을 수 있다.
partial_sum(a.begin(), a.end(), b.begin(), [](int a, int b) { return a + b * b; });
// b = [ 1, 5, 14, 30, 55 ]</code></pre>
</div>
</div>
<h3>3. std::adjacent_difference</h3>
<pre class="language-cpp"><code>template &lt;class InputIterator, class OutputIterator&gt;
  OutputIterator adjacent_difference (InputIterator first, InputIterator last, OutputIterator result);</code></pre>
<p>result로 시작하는 배열에 [ first, last )의 차이 배열 결과를 저장한다. $O(N)$</p>
<p>custom 함수를 이용하면 인접 원소간의 사용자 정의 연산결과를 얻을 수 있다.</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<pre class="language-cpp"><code>vector&lt;int&gt; a = {1, 2, 3, 4, 5};
vector&lt;int&gt; b(a.size());

adjacent_difference(a.begin(), a.end(), b.begin());
// b = [ 1, 1, 1, 1, 1 ]

// custom function 사용이 가능
partial_sum(a.begin(), a.end(), b.begin(), [](int a, int b) { return a + b; });
// b = [ 1, 3, 5, 7, 9 ]</code></pre>
</div>
</div>
<h2>&nbsp;</h2>
<h2>#include &lt;algorithm&gt;</h2>
<h3>1. std::all_of, std::none_of</h3>
<pre class="language-cpp"><code>template &lt;class InputIterator, class UnaryPredicate&gt;
  bool all_of (InputIterator first, InputIterator last, UnaryPredicate pred);</code></pre>
<pre class="language-cpp"><code>template &lt;class InputIterator, class UnaryPredicate&gt;
  bool none_of (InputIterator first, InputIterator last, UnaryPredicate pred);</code></pre>
<p>[ first, last )의 모든 원소가 pred 조건을 만족하는지(혹은 만족하지 않는지) 검사한다. $O(N)$</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<p>a의 모든 원소가 양수인 경우를 처리하기 위해 다음과 같이 써왔다면,&nbsp;</p>
<pre class="language-cpp"><code>auto isValid = [](int *a, int n) {
    for(int i =0; i&lt;n; ++i) if (a[i] &lt; 0) return 0;
    return 1;
};
if (isValid(a, n)) { ... }</code></pre>
<p>다음과 같이 고쳐쓸 수 있다.</p>
<pre class="language-cpp"><code>if (all_of(a, a + n, [](int i) { return i &gt;= 0; })) { ... }</code></pre>
<pre class="language-cpp"><code>if (none_of(a, a + n, [](int i) { return i &lt; 0; })) { ... }</code></pre>
</div>
</div>
<h3>2. std::any_of</h3>
<pre class="language-cpp"><code>template &lt;class InputIterator, class UnaryPredicate&gt;
  bool any_of (InputIterator first, InputIterator last, UnaryPredicate pred);</code></pre>
<p>[ first, last )의 원소 중 pred 조건을 만족하는 원소가 존재하는지 검사한다. $O(N)$</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<p>any_of 와 none_of 는 논리상 역이다.</p>
<p>따라서 1. 의 예시를 다음과 같이도 쓸 수 있다.</p>
<pre class="language-cpp"><code>if (!any_of(a, a + n, [](int i) { return i &lt; 0; })) { ... }</code></pre>
</div>
</div>
<h3>3. std::partition</h3>
<pre class="language-cpp"><code>template &lt;class ForwardIterator, class UnaryPredicate&gt;
  ForwardIterator partition (ForwardIterator first, ForwardIterator last, UnaryPredicate pred);</code></pre>
<p>[ first, last )의 원소를 pred 조건에 따라 2분할하여 배열의 앞, 뒤쪽으로 나누고 뒤쪽 파티션이 시작되는 위치를 반환한다. $O(N)$</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<pre class="language-cpp"><code>vector&lt;int&gt; a = {1, 2, 3, 4, 5, 6, 7, 8, 9};

partition(a.begin(), a.end(), [](int i) { return i &amp; 1; });
// a = [ 1, 9, 3, 7, 5 ], b = [ 6, 4, 8, 2 ]</code></pre>
</div>
</div>
<h3>4. std::equal_range</h3>
<pre class="language-cpp"><code>template &lt;class ForwardIterator, class T&gt;
  pair&lt;ForwardIterator,ForwardIterator&gt;
    equal_range (ForwardIterator first, ForwardIterator last, const T&amp; val);</code></pre>
<p>{ lower_bound(first, last, val), upper_bound(first, last, val) } 페어를 반환한다. $O(lg N)$</p>
<p>이 페어는 곧 배열에서 일치하는 구간의 [ first, last )를 의미하기 때문에 바로 구간탐색에 이용할 수 있다.</p>
<p>당연하게도, lower_bound, upper_bound와 마찬가지로 custom 함수를 이용할 수 있다.</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<pre class="language-cpp"><code>vector&lt;int&gt; a = {1,1,2,2,2,2,3,3,3};

sort(a.begin(), a.end());
auto range = equal_range(a.begin(), a.end(), 2);	// range = {2, 6}
for(auto it = range.first; it != range.second; ++it) {
    ...
}</code></pre>
</div>
</div>
<h3>5. std::merge</h3>
<pre class="language-cpp"><code>template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
  OutputIterator merge (InputIterator1 first1, InputIterator1 last1,
                        InputIterator2 first2, InputIterator2 last2,
                        OutputIterator result);</code></pre>
<p>result로 시작하는 배열에 정렬된 두 배열 [ first1, last1 ), [ first2, last2 )를 합친 정렬된 배열 결과를 저장한다.</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<pre class="language-cpp"><code>vector&lt;int&gt; a = {1, 3, 5};
int b[] = {4, 3, 2};
vector&lt;int&gt; result(6);

// 정렬된 배열에서 올바르게 동작한다.
sort(a.begin(), a.end());
sort(b, b + 3);

merge(a.begin(), a.end(), b, b + 3, result.begin());
// result = [ 1, 2, 3, 3, 4, 5 ]</code></pre>
</div>
</div>
<h3>6. std::set_union (intersection, difference, symmetric_difference)</h3>
<pre class="language-cpp"><code>template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
  OutputIterator set_union (InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2,
                            OutputIterator result);</code></pre>
<p>result로 시작하는 배열에 정렬된 두 집합 배열 [ first1, last1 ), [ first2, last2 )의 합집합(곱집합, 차집합, 상호배타집합) 결과 배열을 저장한다.</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<pre class="language-cpp"><code>vector&lt;int&gt; a = {5, 10, 15, 20, 25};
vector&lt;int&gt; b = {50, 40, 30, 20, 10};
vector&lt;int&gt; result(10);

// 정렬된 배열에서 올바르게 동작한다.
sort(a.begin(), a.end());
sort(b.begin(), b.end());

set_union(a.begin(), a.end(), b.begin(), b.end(), result.begin());
// result = [ 5, 10, 15, 20, 25, 30, 40, 50, 0, 0 ]

set_intersection(a.begin(), a.end(), b.begin(), b.end(), result.begin());
// result = [ 10, 20, 0, 0, 0, 0, 0, 0, 0, 0 ]

set_difference(a.begin(), a.end(), b.begin(), b.end(), result.begin());
// result = [ 5, 15, 25, 0, 0, 0, 0, 0, 0, 0 ]

set_symmetric_difference(a.begin(), a.end(), b.begin(), b.end(), result.begin());
// result = [ 5, 15, 25, 30, 40, 50, 0, 0, 0, 0 ]</code></pre>
</div>
</div>
<h3>7. std::minmax</h3>
<pre class="language-cpp"><code>template &lt;class T&gt;
  pair &lt;const T&amp;,const T&amp;&gt; minmax (const T&amp; a, const T&amp; b);</code></pre>
<p>이름그대로, { min, max }를 pair로 반환한다.</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<pre class="language-cpp"><code>auto mnmx = minmax(24, 17);
// mnmx = { 17, 24 }

auto mnmx = minmax({ 4, 6, 23, 4, 21, 19 });
// mnmx = { 4, 23 }</code></pre>
</div>
</div>
<h3>8. std::next_permutation, std::prev_permutation</h3>
<pre class="language-cpp"><code>template &lt;class BidirectionalIterator&gt;
  bool next_permutation (BidirectionalIterator first,
                         BidirectionalIterator last);</code></pre>
<p>사전순으로 다음(이전) 순열을 만들어주고 1을 반환한다. 사전순으로 다음(이전) 순열이 없는 경우 0을 반환한다.</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<pre class="language-cpp"><code>vector&lt;int&gt; a(4);

iota(a.begin(), a.end(), 1);    // a = [ 1, 2, 3, 4 ]

do {
    for(int i : a) cout &lt;&lt; i &lt;&lt; ' ';
    cout &lt;&lt; '\n';
} while(next_permutation(a.begin(), a.end()));

a = [ 1, 2, 4, 3 ]
a = [ 1, 3, 2, 4 ]
a = [ 1, 3, 4, 2 ]
 ...</code></pre>
<p>순열 조합 탐색 문제에서 유용하게 활용할 수 있다.</p>
</div>
</div>
<h3>&nbsp;</h3>
<h3>+ algorithm header에서 접미사의 의미</h3>
<h4>1. _n</h4>
<p>특정 함수의 경우 _n을 붙여주면 first 에서 last 까지가 아닌, first 에서 n 개 만큼만 실행한다.</p>
<p>last를 begin + n으로 나타내면 어차피 원함수랑 똑같아지니 있으나마나긴 하다.</p>
<p>_n이 구현된 함수 : search, copy, fill, generate</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<pre class="language-cpp"><code>vector&lt;int&gt; a(4);

fill(a.begin(), a.end(), 4);
// a = [ 4, 4, 4, 4 ]

fill_n(a.begin(), 3, 1);   // = fill(a.begin(), a.begin() + 3, 1);
// a = [ 1, 1, 1, 4 ]</code></pre>
</div>
</div>
<h4>2. _copy</h4>
<p>원래의 배열과 함수 실행결과 배열이 동시에 필요한 경우가 있다.</p>
<p>특정 함수의 경우 접미사로 _copy를 붙여주면 함수수행 결과를 다른 배열에 저장한다.</p>
<p>_copy가 구현된 함수 : replace, unique, remove, reverse, rotate, partition, partial_sort</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<pre class="language-cpp"><code>vector&lt;int&gt; a = {1, 2, 3, 4, 5}, ra;
ra = a;
reverse(ra.begin(), ra.end());</code></pre>
<p>위의 코드를 다음과 같이 쓸 수 있다.</p>
<pre class="language-cpp"><code>vector&lt;int&gt; a = {1, 2, 3, 4, 5}, ra(a.size());
reverse_copy(a.begin(), a.end(), ra.begin());</code></pre>
<p>뭐가 달라진건가 싶지만 위의 코드의 경우 ra로의 복사$(O(N))$와 reverse$(O(N))$로 총 $O(2N)$이고,</p>
<p>아래의 코드는 $O(N)$이다.</p>
</div>
</div>
<h4>3. _if</h4>
<p>조건에 맞는 원소에 한해서만 함수 실행을 하는 옵션이다.</p>
<p>접미사로 _if를 붙이면 pred함수의 결과가 참인 원소들만 함수가 적용된다.</p>
<p>_if가 구현된 함수 : find, count, copy, replace, remove, replace_copy, remove_copy</p>
<div data-ke-type="moreLess" data-text-more="예시" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<pre class="language-cpp"><code>vector&lt;int&gt; a = {1, -1, 3, 0, -2, 5};

replace_if(a.begin(), a.end(), [](int i) { return i &lt; 0; }, 99);
a = [ 1, 99, 3, 0, 99, 5 ]</code></pre>
</div>
</div>
<p>&nbsp;</p>